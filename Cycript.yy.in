/* Cycript - Optimizing JavaScript Compiler/Runtime
 * Copyright (C) 2009-2010  Jay Freeman (saurik)
*/

/* GNU Lesser General Public License, Version 3 {{{ */
/*
 * Cycript is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Cycript is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Cycript.  If not, see <http://www.gnu.org/licenses/>.
**/
/* }}} */

@if Bison23 %{

@if Bison24 %code top {
#define cyscanner driver.scanner_
#define YYSTACKEXPANDABLE 1
@if Bison23 #define yyerrok (yyerrstatus_ = 0)
@if Bison24 }

@if Bison24 %code requires {
#include "Parser.hpp"
#define CYNew new($pool)

@begin ObjectiveC
#include "ObjectiveC/Syntax.hpp"
@end

@begin E4X
#include "E4X/Syntax.hpp"
@end

typedef struct {
    bool newline_;

    union {
        bool bool_;

        CYDriver::Condition condition_;

        CYArgument *argument_;
        CYAssignment *assignment_;
        CYBoolean *boolean_;
        CYClause *clause_;
        cy::Syntax::Catch *catch_;
        CYComment *comment_;
        CYComprehension *comprehension_;
        CYCompound *compound_;
        CYDeclaration *declaration_;
        CYDeclarations *declarations_;
        CYElement *element_;
        CYExpression *expression_;
        CYFalse *false_;
        CYFinally *finally_;
        CYForInitialiser *for_;
        CYForInInitialiser *forin_;
        CYFunctionParameter *functionParameter_;
        CYIdentifier *identifier_;
        CYInfix *infix_;
        CYLiteral *literal_;
        CYMember *member_;
        CYNull *null_;
        CYNumber *number_;
        CYProgram *program_;
        CYProperty *property_;
        CYPropertyName *propertyName_;
        CYRubyProc *rubyProc_;
        CYStatement *statement_;
        CYString *string_;
        CYThis *this_;
        CYTrue *true_;
        CYWord *word_;

@begin ObjectiveC
        CYClassName *className_;
        CYField *field_;
        CYMessage *message_;
        CYMessageParameter *messageParameter_;
        CYProtocol *protocol_;
        CYSelectorPart *selector_;
@end

@begin E4X
        CYAttribute *attribute_;
        CYPropertyIdentifier *propertyIdentifier_;
        CYSelector *selector_;
@end
    };
} YYSTYPE;

#define YYSTYPE YYSTYPE
@if Bison24 }

@if Bison24 %code provides {
int cylex(YYSTYPE *, cy::location *, void *);
@if Bison24 }

@if Bison23 %}

%name-prefix="cy"

@if Bison23 %skeleton "lalr1.cc"
@if Bison24 %language "C++"

%initial-action {
    @$.begin.filename = @$.end.filename = &driver.filename_;
};

%locations
%defines

//%glr-parser
//%expect 1

%error-verbose

%parse-param { CYDriver &driver }
%lex-param { void *cyscanner }

@begin E4X
%token XMLCDATA
%token XMLComment
%token XMLPI

%token XMLAttributeValue
%token XMLName
%token XMLTagCharacters
%token XMLText
%token XMLWhitespace
@end

@begin E4X
%token LeftRight "<>"
%token LeftSlashRight "</>"

%token SlashRight "/>"
%token LeftSlash "</"

%token ColonColon "::"
%token PeriodPeriod ".."
@end

@begin E4X ObjectiveC
%token At "@"
@end

%token Ampersand "&"
%token AmpersandAmpersand "&&"
%token AmpersandEqual "&="
%token Carrot "^"
%token CarrotEqual "^="
%token Equal "="
%token EqualEqual "=="
%token EqualEqualEqual "==="
%token Exclamation "!"
%token ExclamationEqual "!="
%token ExclamationEqualEqual "!=="
%token Hyphen "-"
%token HyphenEqual "-="
%token HyphenHyphen "--"
%token HyphenHyphen_ "\n--"
%token HyphenRight "->"
%token Left "<"
%token LeftEqual "<="
%token LeftLeft "<<"
%token LeftLeftEqual "<<="
%token Percent "%"
%token PercentEqual "%="
%token Period "."
%token Pipe "|"
%token PipeEqual "|="
%token PipePipe "||"
%token Plus "+"
%token PlusEqual "+="
%token PlusPlus "++"
%token PlusPlus_ "\n++"
%token Right ">"
%token RightEqual ">="
%token RightRight ">>"
%token RightRightEqual ">>="
%token RightRightRight ">>>"
%token RightRightRightEqual ">>>="
%token Slash "/"
%token SlashEqual "/="
%token Star "*"
%token StarEqual "*="
%token Tilde "~"

%token Colon ":"
%token Comma ","
%token Question "?"
%token SemiColon ";"
%token NewLine "\n"

%token <comment_> Comment

%token OpenParen "("
%token CloseParen ")"

%token OpenBrace "{"
%token OpenBrace_ "\n{"
%token CloseBrace "}"

%token OpenBracket "["
%token CloseBracket "]"

@begin Java
%token AtClass "@class"
@end

@begin ObjectiveC
%token AtImplementation "@implementation"
%token AtImport "@import"
%token AtEnd "@end"
%token AtSelector "@selector"
@end

%token <false_> False "false"
%token <null_> Null "null"
%token <true_> True "true"

// ES3/ES5/WIE/JSC Reserved
%token <word_> Break "break"
%token <word_> Case "case"
%token <word_> Catch "catch"
%token <word_> Continue "continue"
%token <word_> Default "default"
%token <word_> Delete "delete"
%token <word_> Do "do"
%token <word_> Else "else"
%token <word_> Finally "finally"
%token <word_> For "for"
%token <word_> Function "function"
%token <word_> If "if"
%token <word_> In "in"
%token <word_> InstanceOf "instanceof"
%token <word_> New "new"
%token <word_> Return "return"
%token <word_> Switch "switch"
%token <this_> This "this"
%token <word_> Throw "throw"
%token <word_> Try "try"
%token <word_> TypeOf "typeof"
%token <word_> Var "var"
%token <word_> Void "void"
%token <word_> While "while"
%token <word_> With "with"

// ES3/IE6 Future, ES5/JSC Reserved
%token <word_> Debugger "debugger"

// ES3/ES5/IE6 Future, JSC Reserved
%token <word_> Const "const"

// ES3/ES5/IE6/JSC Future
%token <word_> Class "class"
%token <word_> Enum "enum"
%token <word_> Export "export"
%token <word_> Extends "extends"
%token <word_> Import "import"
%token <word_> Super "super"

// ES3 Future, ES5 Strict Future
%token <identifier_> Implements "implements"
%token <identifier_> Interface "interface"
%token <identifier_> Package "package"
%token <identifier_> Private "private"
%token <identifier_> Protected "protected"
%token <identifier_> Public "public"
%token <identifier_> Static "static"

// ES3 Future
%token <identifier_> Abstract "abstract"
%token <identifier_> Boolean "boolean"
%token <identifier_> Byte "byte"
%token <identifier_> Char "char"
%token <identifier_> Double "double"
%token <identifier_> Final "final"
%token <identifier_> Float "float"
%token <identifier_> Goto "goto"
%token <identifier_> Int "int"
%token <identifier_> Long "long"
%token <identifier_> Native "native"
%token <identifier_> Short "short"
%token <identifier_> Synchronized "synchronized"
%token <identifier_> Throws "throws"
%token <identifier_> Transient "transient"
%token <identifier_> Volatile "volatile"

// ES5 Strict
%token <identifier_> Let "let"
%token <identifier_> Yield "yield"

// Woah?!
%token <identifier_> Each "each"

@begin E4X
// E4X Conditional
%token <identifier_> Namespace "namespace"
%token <identifier_> XML "xml"
@end

%token AutoComplete

%token <identifier_> Identifier_
%token <number_> NumericLiteral
%token <string_> StringLiteral
%token <literal_> RegularExpressionLiteral

%type <expression_> AdditiveExpression
%type <expression_> AdditiveExpressionNoBF
%type <argument_> ArgumentList
%type <argument_> ArgumentList_
%type <argument_> ArgumentListOpt
%type <argument_> Arguments
%type <literal_> ArrayLiteral
%type <expression_> AssigneeExpression
%type <expression_> AssigneeExpressionNoBF
%type <expression_> AssignmentExpression
%type <assignment_> AssignmentExpression_
%type <expression_> AssignmentExpressionNoBF
%type <expression_> AssignmentExpressionNoIn
%type <expression_> BitwiseANDExpression
%type <expression_> BitwiseANDExpressionNoBF
%type <expression_> BitwiseANDExpressionNoIn
%type <statement_> Block
%type <statement_> Block_
%type <boolean_> BooleanLiteral
%type <expression_> BitwiseORExpression
%type <expression_> BitwiseORExpressionNoBF
%type <expression_> BitwiseORExpressionNoIn
%type <expression_> BitwiseXORExpression
%type <expression_> BitwiseXORExpressionNoBF
%type <expression_> BitwiseXORExpressionNoIn
%type <statement_> BreakStatement
%type <expression_> CallExpression
%type <expression_> CallExpressionNoBF
%type <clause_> CaseBlock
%type <clause_> CaseClause
%type <clause_> CaseClausesOpt
%type <catch_> CatchOpt
%type <comprehension_> ComprehensionList
%type <comprehension_> ComprehensionListOpt
%type <expression_> ConditionalExpression
%type <expression_> ConditionalExpressionNoBF
%type <expression_> ConditionalExpressionNoIn
%type <statement_> ContinueStatement
%type <clause_> DefaultClause
%type <statement_> DoWhileStatement
%type <expression_> Element
%type <expression_> ElementOpt
%type <element_> ElementList
%type <element_> ElementListOpt
%type <statement_> ElseStatementOpt
%type <statement_> EmptyStatement
%type <expression_> EqualityExpression
%type <expression_> EqualityExpressionNoBF
%type <expression_> EqualityExpressionNoIn
%type <expression_> Expression
%type <expression_> ExpressionOpt
%type <compound_> Expression_
%type <expression_> ExpressionNoBF
%type <expression_> ExpressionNoIn
%type <compound_> ExpressionNoIn_
%type <expression_> ExpressionNoInOpt
%type <statement_> ExpressionStatement
%type <finally_> FinallyOpt
%type <comprehension_> ForComprehension
%type <statement_> ForStatement
%type <for_> ForStatementInitialiser
%type <statement_> ForInStatement
%type <forin_> ForInStatementInitialiser
%type <functionParameter_> FormalParameterList
%type <functionParameter_> FormalParameterList_
%type <statement_> FunctionBody
%type <statement_> FunctionDeclaration
%type <expression_> FunctionExpression
%type <identifier_> Identifier
%type <identifier_> IdentifierOpt
%type <comprehension_> IfComprehension
%type <statement_> IfStatement
%type <expression_> Initialiser
%type <expression_> InitialiserOpt
%type <expression_> InitialiserNoIn
%type <expression_> InitialiserNoInOpt
%type <statement_> IterationStatement
%type <statement_> LabelledStatement
%type <expression_> LeftHandSideExpression
%type <expression_> LeftHandSideExpressionNoBF
//%type <statement_> LetStatement
%type <literal_> Literal
%type <literal_> LiteralNoRE
%type <literal_> LiteralRE
%type <expression_> LogicalANDExpression
%type <expression_> LogicalANDExpressionNoBF
%type <expression_> LogicalANDExpressionNoIn
%type <expression_> LogicalORExpression
%type <expression_> LogicalORExpressionNoBF
%type <expression_> LogicalORExpressionNoIn
%type <member_> MemberAccess
%type <expression_> MemberExpression
%type <expression_> MemberExpression_
%type <expression_> MemberExpressionNoBF
%type <expression_> MultiplicativeExpression
%type <expression_> MultiplicativeExpressionNoBF
%type <expression_> NewExpression
%type <expression_> NewExpression_
%type <expression_> NewExpressionNoBF
%type <null_> NullLiteral
%type <literal_> ObjectLiteral
%type <expression_> PostfixExpression
%type <expression_> PostfixExpressionNoBF
%type <expression_> PrimaryExpression
%type <expression_> PrimaryExpressionNo
%type <expression_> PrimaryExpressionNoBF
%type <expression_> PrimaryExpressionNoRE
%type <expression_> PrimaryExpressionBF
%type <statement_> Program
%type <propertyName_> PropertyName
%type <propertyName_> PropertyName_
%type <property_> PropertyNameAndValueList
%type <property_> PropertyNameAndValueList_
%type <property_> PropertyNameAndValueListOpt
%type <expression_> RelationalExpression
%type <infix_> RelationalExpression_
%type <expression_> RelationalExpressionNoBF
%type <expression_> RelationalExpressionNoIn
%type <infix_> RelationalExpressionNoIn_
%type <statement_> ReturnStatement
%type <rubyProc_> RubyProcExpression
%type <functionParameter_> RubyProcParameterList
%type <functionParameter_> RubyProcParameterList_
%type <functionParameter_> RubyProcParametersOpt
%type <expression_> ShiftExpression
%type <expression_> ShiftExpressionNoBF
%type <statement_> SourceElement
%type <statement_> SourceElement_
%type <statement_> SourceElements
%type <statement_> Statement
%type <statement_> Statement_
%type <statement_> StatementList
%type <statement_> StatementListOpt
%type <statement_> SwitchStatement
%type <statement_> ThrowStatement
%type <statement_> TryStatement
%type <expression_> UnaryExpression
%type <expression_> UnaryExpression_
%type <expression_> UnaryExpressionNoBF
%type <declaration_> VariableDeclaration
%type <declaration_> VariableDeclarationNoIn
%type <declarations_> VariableDeclarationList
%type <declarations_> VariableDeclarationList_
%type <declarations_> VariableDeclarationListNoIn
%type <declarations_> VariableDeclarationListNoIn_
%type <statement_> VariableStatement
%type <statement_> WhileStatement
%type <statement_> WithStatement

@begin C
%type <expression_> AssigneeExpressionNoRE
%type <expression_> CallExpressionNoRE
%type <expression_> LeftHandSideExpressionNoRE
%type <expression_> MemberExpressionNoRE
%type <expression_> NewExpressionNoRE
%type <expression_> PostfixExpressionNoRE
%type <expression_> UnaryAssigneeExpression
%type <expression_> UnaryExpressionNoRE
@end

@begin ObjectiveC
%type <statement_> CategoryStatement
%type <expression_> ClassExpression
%type <statement_> ClassStatement
%type <expression_> ClassSuperOpt
%type <field_> ClassFieldList
%type <message_> ClassMessageDeclaration
%type <message_> ClassMessageDeclarationListOpt
%type <className_> ClassName
%type <className_> ClassNameOpt
%type <protocol_> ClassProtocolListOpt
%type <protocol_> ClassProtocols
%type <protocol_> ClassProtocolsOpt
%type <expression_> MessageExpression
%type <messageParameter_> MessageParameter
%type <messageParameter_> MessageParameters
%type <messageParameter_> MessageParameterList
%type <messageParameter_> MessageParameterListOpt
%type <bool_> MessageScope
%type <argument_> SelectorCall
%type <argument_> SelectorCall_
%type <selector_> SelectorExpression
%type <selector_> SelectorExpression_
%type <selector_> SelectorExpressionOpt
%type <argument_> SelectorList
%type <word_> SelectorWordOpt
%type <expression_> TypeOpt
%type <argument_> VariadicCall
%type <word_> Word
%type <word_> WordOpt
@end

@begin E4X
%type <propertyIdentifier_> PropertyIdentifier_
%type <selector_> PropertySelector
%type <selector_> PropertySelector_
%type <identifier_> QualifiedIdentifier
%type <identifier_> QualifiedIdentifier_
%type <identifier_> WildcardIdentifier
%type <identifier_> XMLComment
%type <identifier_> XMLCDATA
%type <identifier_> XMLElement
%type <identifier_> XMLElementContent
%type <identifier_> XMLMarkup
%type <identifier_> XMLPI

%type <attribute_> AttributeIdentifier
/* XXX: %type <statement_> DefaultXMLNamespaceStatement */
%type <expression_> PropertyIdentifier
%type <expression_> XMLListInitialiser
%type <expression_> XMLInitialiser
@end

%nonassoc Identifier_ "abstract" "boolean" "break" "byte" "case" "catch" "char" "class" "const" "continue" "debugger" "default" "delete" "do" "double" "each" "enum" "export" "extends" "false" "final" "finally" "float" /*"for"*/ "function" "goto" "implements" "import" /*"in"*/ /*"instanceof"*/ "int" "interface" "let" "long" "namespace" "native" "new" "null" "package" "private" "protected" "public" "return" "short" "super" "static" "switch" "synchronized" "this" "throw" "throws" "transient" "true" "try" "typeof" "var" "void" "volatile" "while" "with" "xml" "yield"

%nonassoc "if"
%nonassoc "else"

%nonassoc "++" "--"
%nonassoc "(" "["

%left "*" "/" "%"
%left "+" "-"
%left "<<" ">>" ">>>"
%left "<" ">" "<=" ">=" "instanceof" "in"
%left "==" "!=" "===" "!=="
%left "&"
%left "^"
%left "|"
%left "&&"
%left "||"

%right "=" "*=" "/=" "%=" "+=" "-=" "<<=" ">>=" ">>>=" "&=" "^=" "|="

%start Program

%%

/* Lexer State {{{ */
LexSetRegExp
    : { driver.SetCondition(CYDriver::RegExpCondition); }
    ;
/* }}} */

Brace
    : "{"
    | "\n{"
    ;

StrictSemi
    : { driver.Warning(yylloc, "warning, automatic semi-colon insertion required"); }
    ;

Terminator_
    : ";"
    | "\n" StrictSemi
    ;

TerminatorOpt
    : Terminator_
    | error { yyerrok; driver.errors_.pop_back(); } StrictSemi
    ;

Terminator
    : Terminator_
    | error { if (yychar != 0 && yychar != cy::parser::token::CloseBrace && !yylval.newline_) YYABORT; else { yyerrok; driver.errors_.pop_back(); } } StrictSemi
    ;

/*CommaOpt
    : ","
    |
    ;*/

@begin ObjectiveC
NewLineOpt
    : "\n"
    |
    ;

WordOpt
    : Word { $$ = $1; }
    | { $$ = NULL; }
    ;

Word
    : Identifier { $$ = $1; }
    | "break" NewLineOpt { $$ = $1; }
    | "case" { $$ = $1; }
    | "catch" { $$ = $1; }
    | "class" { $$ = $1; }
    | "const" { $$ = $1; }
    | "continue" NewLineOpt { $$ = $1; }
    | "debugger" { $$ = $1; }
    | "default" { $$ = $1; }
    | "delete" { $$ = $1; }
    | "do" { $$ = $1; }
    | "else" { $$ = $1; }
    | "enum" { $$ = $1; }
    | "export" { $$ = $1; }
    | "extends" { $$ = $1; }
    | "false" { $$ = $1; }
    | "finally" { $$ = $1; }
    /* XXX: | "for" { $$ = $1; } */
    | "function" { $$ = $1; }
    | "if" { $$ = $1; }
    | "import" { $$ = $1; }
    /* XXX: | "in" { $$ = $1; } */
    /* XXX: | "instanceof" { $$ = $1; } */
    | "new" { $$ = $1; }
    | "null" { $$ = $1; }
    | "return" NewLineOpt { $$ = $1; }
    | "super" { $$ = $1; }
    | "switch" { $$ = $1; }
    | "this" { $$ = $1; }
    | "throw" NewLineOpt { $$ = $1; }
    | "true" { $$ = $1; }
    | "try" { $$ = $1; }
    | "typeof" { $$ = $1; }
    | "var" { $$ = $1; }
    | "void" { $$ = $1; }
    | "while" { $$ = $1; }
    | "with" { $$ = $1; }
    ;
@end

Identifier
    : Identifier_ { $$ = $1; }

    | "implements" { $$ = $1; }
    | "interface" { $$ = $1; }
    | "package" { $$ = $1; }
    | "private" { $$ = $1; }
    | "protected" { $$ = $1; }
    | "public" { $$ = $1; }
    | "static" { $$ = $1; }

    | "abstract" { $$ = $1; }
    | "boolean" { $$ = $1; }
    | "byte" { $$ = $1; }
    | "char" { $$ = $1; }
    | "double" { $$ = $1; }
    | "final" { $$ = $1; }
    | "float" { $$ = $1; }
    | "goto" { $$ = $1; }
    | "int" { $$ = $1; }
    | "long" { $$ = $1; }
    | "native" { $$ = $1; }
    | "short" { $$ = $1; }
    | "synchronized" { $$ = $1; }
    | "throws" { $$ = $1; }
    | "transient" { $$ = $1; }
    | "volatile" { $$ = $1; }

    | "let" { $$ = $1; }
    | "yield" { $$ = $1; }

    | "each" { $$ = $1; }
    ;

IdentifierOpt
    : Identifier { $$ = $1; }
    | { $$ = NULL; }
    ;

LiteralNoRE
    : NullLiteral { $$ = $1; }
    | BooleanLiteral { $$ = $1; }
    | NumericLiteral { $$ = $1; }
    | StringLiteral { $$ = $1; }
    | "@" StringLiteral { $$ = $2; }
    ;

LiteralRE
    : RegularExpressionLiteral { $$ = $1; }
    ;

Literal
    : LiteralNoRE { $$ = $1; }
    | LiteralRE { $$ = $1; }
    ;

NullLiteral
    : "null" { $$ = $1; }
    ;

BooleanLiteral
    : "true" { $$ = $1; }
    | "false" { $$ = $1; }
    ;

/* 11.1 Primary Expressions {{{ */
PrimaryExpression
    : LexSetRegExp PrimaryExpressionNoRE { $$ = $2; }
    ;

PrimaryExpressionNoBF
    : PrimaryExpressionNo { $$ = $1; }
    ;

PrimaryExpressionNoRE
    : PrimaryExpressionBF { $$ = $1; }
    | PrimaryExpressionNo { $$ = $1; }
    ;

PrimaryExpressionNo
    : "this" { $$ = $1; }
    | Identifier { $$ = CYNew CYVariable($1); }
    | AutoComplete { driver.mode_ = CYDriver::AutoPrimary; YYACCEPT; }
    | Literal { $$ = $1; }
    | ArrayLiteral { $$ = $1; }
    | "(" Expression ")" { $$ = $2; }
    ;

PrimaryExpressionBF
    : ObjectLiteral { $$ = $1; }
    ;
/* }}} */
/* 11.1.4 Array Initialiser {{{ */
ArrayLiteral
    : "[" ElementListOpt "]" { $$ = CYNew CYArray($2); }
    ;

Element
    : AssignmentExpression { $$ = $1; }
    ;

ElementOpt
    : Element { $$ = $1; }
    | LexSetRegExp { $$ = NULL; }
    ;

ElementListOpt
    : ElementList { $$ = $1; }
    | LexSetRegExp { $$ = NULL; }
    ;

ElementList
    : ElementOpt "," ElementListOpt { $$ = CYNew CYElement($1, $3); }
    | Element { $$ = CYNew CYElement($1, NULL); }
    ;
/* }}} */
/* 11.1.5 Object Initialiser {{{ */
ObjectLiteral
    : OpenBrace PropertyNameAndValueListOpt "}" { $$ = CYNew CYObject($2); }
    ;

PropertyNameAndValueList_
    : "," PropertyNameAndValueList { $$ = $2; }
    | { $$ = NULL; }
    ;

PropertyNameAndValueListOpt
    : PropertyNameAndValueList { $$ = $1; }
    | { $$ = NULL; }
    ;

PropertyNameAndValueList
    : PropertyName ":" AssignmentExpression PropertyNameAndValueList_ { $$ = CYNew CYProperty($1, $3, $4); }
    ;

PropertyName_
    : Identifier { $$ = $1; }
    | StringLiteral { $$ = $1; }
    | NumericLiteral { $$ = $1; }
    ;

PropertyName
    : LexSetRegExp PropertyName_ { $$ = $2; }
    ;
/* }}} */

/* 11.2 Left-Hand-Side Expressions {{{ */
MemberExpression_
    : "new" MemberExpression Arguments { $$ = CYNew cy::Syntax::New($2, $3); }
    ;

MemberAccess
    : "[" Expression "]" { $$ = CYNew CYDirectMember(NULL, $2); }
    | "." Identifier { $$ = CYNew CYDirectMember(NULL, CYNew CYString($2)); }
    | "." AutoComplete { driver.mode_ = CYDriver::AutoDirect; YYACCEPT; }
    ;

MemberExpression
    : PrimaryExpression { $$ = $1; }
    | LexSetRegExp FunctionExpression { $$ = $2; }
    | MemberExpression { driver.context_ = $1; } MemberAccess { $3->SetLeft($1); $$ = $3; }
    | LexSetRegExp MemberExpression_ { $$ = $2; }
    ;

MemberExpressionNoBF
    : PrimaryExpressionNoBF { $$ = $1; }
    | MemberExpressionNoBF { driver.context_ = $1; } MemberAccess { $3->SetLeft($1); $$ = $3; }
    | MemberExpression_ { $$ = $1; }
    ;

@begin C
MemberExpressionNoRE
    : PrimaryExpressionNoRE { $$ = $1; }
    | FunctionExpression { $$ = $1; }
    | MemberExpressionNoRE { driver.context_ = $1; } MemberAccess { $3->SetLeft($1); $$ = $3; }
    | MemberExpression_ { $$ = $1; }
    ;
@end

NewExpression_
    : "new" NewExpression { $$ = CYNew cy::Syntax::New($2, NULL); }
    ;

NewExpression
    : MemberExpression { $$ = $1; }
    | LexSetRegExp NewExpression_ { $$ = $2; }
    ;

NewExpressionNoBF
    : MemberExpressionNoBF { $$ = $1; }
    | NewExpression_ { $$ = $1; }
    ;

@begin C
NewExpressionNoRE
    : MemberExpressionNoRE { $$ = $1; }
    | NewExpression_ { $$ = $1; }
    ;
@end

CallExpression
    : MemberExpression Arguments { $$ = CYNew CYCall($1, $2); }
    | CallExpression Arguments { $$ = CYNew CYCall($1, $2); }
    | CallExpression { driver.context_ = $1; } MemberAccess { $3->SetLeft($1); $$ = $3; }
    ;

CallExpressionNoBF
    : MemberExpressionNoBF Arguments { $$ = CYNew CYCall($1, $2); }
    | CallExpressionNoBF Arguments { $$ = CYNew CYCall($1, $2); }
    | CallExpressionNoBF { driver.context_ = $1; } MemberAccess { $3->SetLeft($1); $$ = $3; }
    ;

@begin C
CallExpressionNoRE
    : MemberExpressionNoRE Arguments { $$ = CYNew CYCall($1, $2); }
    | CallExpressionNoRE Arguments { $$ = CYNew CYCall($1, $2); }
    | CallExpressionNoRE { driver.context_ = $1; } MemberAccess { $3->SetLeft($1); $$ = $3; }
    ;
@end

ArgumentList_
    : "," ArgumentList { $$ = $2; }
    | { $$ = NULL; }
    ;

ArgumentListOpt
    : ArgumentList { $$ = $1; }
    | LexSetRegExp { $$ = NULL; }
    ;

ArgumentList
    : AssignmentExpression ArgumentList_ { $$ = CYNew CYArgument(NULL, $1, $2); }
    ;

Arguments
    : "(" ArgumentListOpt ")" { $$ = $2; }
    ;

LeftHandSideExpression
    : NewExpression { $$ = $1; }
    | CallExpression { $$ = $1; }
    ;

LeftHandSideExpressionNoBF
    : NewExpressionNoBF { $$ = $1; }
    | CallExpressionNoBF { $$ = $1; }
    ;

@begin C
LeftHandSideExpressionNoRE
    : NewExpressionNoRE { $$ = $1; }
    | CallExpressionNoRE { $$ = $1; }
    ;
@end
/* }}} */
/* 11.3 Postfix Expressions {{{ */
PostfixExpression
    : AssigneeExpression { $$ = $1; }
    | LeftHandSideExpression "++" { $$ = CYNew CYPostIncrement($1); }
    | LeftHandSideExpression "--" { $$ = CYNew CYPostDecrement($1); }
    ;

PostfixExpressionNoBF
    : AssigneeExpressionNoBF { $$ = $1; }
    | LeftHandSideExpressionNoBF "++" { $$ = CYNew CYPostIncrement($1); }
    | LeftHandSideExpressionNoBF "--" { $$ = CYNew CYPostDecrement($1); }
    ;

@begin C
PostfixExpressionNoRE
    : AssigneeExpressionNoRE { $$ = $1; }
    | LeftHandSideExpressionNoRE "++" { $$ = CYNew CYPostIncrement($1); }
    | LeftHandSideExpressionNoRE "--" { $$ = CYNew CYPostDecrement($1); }
    ;
@end
/* }}} */
/* 11.4 Unary Operators {{{ */
UnaryExpression_
    : "delete" UnaryExpression { $$ = CYNew CYDelete($2); }
    | "void" UnaryExpression { $$ = CYNew CYVoid($2); }
    | "typeof" UnaryExpression { $$ = CYNew CYTypeOf($2); }
    | "++" UnaryExpression { $$ = CYNew CYPreIncrement($2); }
    | "\n++" UnaryExpression { $$ = CYNew CYPreIncrement($2); }
    | "--" UnaryExpression { $$ = CYNew CYPreDecrement($2); }
    | "\n--" UnaryExpression { $$ = CYNew CYPreDecrement($2); }
    | "+" UnaryExpression { $$ = CYNew CYAffirm($2); }
    | "-" UnaryExpression { $$ = CYNew CYNegate($2); }
    | "~" UnaryExpression { $$ = CYNew CYBitwiseNot($2); }
    | "!" UnaryExpression { $$ = CYNew CYLogicalNot($2); }
    ;

UnaryExpression
    : PostfixExpression { $$ = $1; }
    | LexSetRegExp UnaryExpression_ { $$ = $2; }
    ;

UnaryExpressionNoBF
    : PostfixExpressionNoBF { $$ = $1; }
    | UnaryExpression_ { $$ = $1; }
    ;

@begin C
UnaryExpressionNoRE
    : PostfixExpressionNoRE { $$ = $1; }
    | UnaryExpression_ { $$ = $1; }
    ;
@end
/* }}} */
/* 11.5 Multiplicative Operators {{{ */
MultiplicativeExpression
    : UnaryExpression { $$ = $1; }
    | MultiplicativeExpression "*" UnaryExpression { $$ = CYNew CYMultiply($1, $3); }
    | MultiplicativeExpression "/" UnaryExpression { $$ = CYNew CYDivide($1, $3); }
    | MultiplicativeExpression "%" UnaryExpression { $$ = CYNew CYModulus($1, $3); }
    ;

MultiplicativeExpressionNoBF
    : UnaryExpressionNoBF { $$ = $1; }
    | MultiplicativeExpressionNoBF "*" UnaryExpression { $$ = CYNew CYMultiply($1, $3); }
    | MultiplicativeExpressionNoBF "/" UnaryExpression { $$ = CYNew CYDivide($1, $3); }
    | MultiplicativeExpressionNoBF "%" UnaryExpression { $$ = CYNew CYModulus($1, $3); }
    ;
/* }}} */
/* 11.6 Additive Operators {{{ */
AdditiveExpression
    : MultiplicativeExpression { $$ = $1; }
    | AdditiveExpression "+" MultiplicativeExpression { $$ = CYNew CYAdd($1, $3); }
    | AdditiveExpression "-" MultiplicativeExpression { $$ = CYNew CYSubtract($1, $3); }
    ;

AdditiveExpressionNoBF
    : MultiplicativeExpressionNoBF { $$ = $1; }
    | AdditiveExpressionNoBF "+" MultiplicativeExpression { $$ = CYNew CYAdd($1, $3); }
    | AdditiveExpressionNoBF "-" MultiplicativeExpression { $$ = CYNew CYSubtract($1, $3); }
    ;
/* }}} */
/* 11.7 Bitwise Shift Operators {{{ */
ShiftExpression
    : AdditiveExpression { $$ = $1; }
    | ShiftExpression "<<" AdditiveExpression { $$ = CYNew CYShiftLeft($1, $3); }
    | ShiftExpression ">>" AdditiveExpression { $$ = CYNew CYShiftRightSigned($1, $3); }
    | ShiftExpression ">>>" AdditiveExpression { $$ = CYNew CYShiftRightUnsigned($1, $3); }
    ;

ShiftExpressionNoBF
    : AdditiveExpressionNoBF { $$ = $1; }
    | ShiftExpressionNoBF "<<" AdditiveExpression { $$ = CYNew CYShiftLeft($1, $3); }
    | ShiftExpressionNoBF ">>" AdditiveExpression { $$ = CYNew CYShiftRightSigned($1, $3); }
    | ShiftExpressionNoBF ">>>" AdditiveExpression { $$ = CYNew CYShiftRightUnsigned($1, $3); }
    ;
/* }}} */
/* 11.8 Relational Operators {{{ */
RelationalExpressionNoIn_
    : "<" ShiftExpression { $$ = CYNew CYLess(NULL, $2); }
    | ">" ShiftExpression { $$ = CYNew CYGreater(NULL, $2); }
    | "<=" ShiftExpression { $$ = CYNew CYLessOrEqual(NULL, $2); }
    | ">=" ShiftExpression { $$ = CYNew CYGreaterOrEqual(NULL, $2); }
    | "instanceof" ShiftExpression { $$ = CYNew CYInstanceOf(NULL, $2); }
    ;

RelationalExpression_
    : RelationalExpressionNoIn_ { $$ = $1; }
    | "in" ShiftExpression { $$ = CYNew CYIn(NULL, $2); }
    ;

RelationalExpression
    : ShiftExpression { $$ = $1; }
    | RelationalExpression RelationalExpression_ { $2->SetLeft($1); $$ = $2; }
    ;

RelationalExpressionNoIn
    : ShiftExpression { $$ = $1; }
    | RelationalExpressionNoIn RelationalExpressionNoIn_ { $2->SetLeft($1); $$ = $2; }
    ;

RelationalExpressionNoBF
    : ShiftExpressionNoBF { $$ = $1; }
    | RelationalExpressionNoBF RelationalExpression_ { $2->SetLeft($1); $$ = $2; }
    ;
/* }}} */
/* 11.9 Equality Operators {{{ */
EqualityExpression
    : RelationalExpression { $$ = $1; }
    | EqualityExpression "==" RelationalExpression { $$ = CYNew CYEqual($1, $3); }
    | EqualityExpression "!=" RelationalExpression { $$ = CYNew CYNotEqual($1, $3); }
    | EqualityExpression "===" RelationalExpression { $$ = CYNew CYIdentical($1, $3); }
    | EqualityExpression "!==" RelationalExpression { $$ = CYNew CYNotIdentical($1, $3); }
    ;

EqualityExpressionNoIn
    : RelationalExpressionNoIn { $$ = $1; }
    | EqualityExpressionNoIn "==" RelationalExpressionNoIn { $$ = CYNew CYEqual($1, $3); }
    | EqualityExpressionNoIn "!=" RelationalExpressionNoIn { $$ = CYNew CYNotEqual($1, $3); }
    | EqualityExpressionNoIn "===" RelationalExpressionNoIn { $$ = CYNew CYIdentical($1, $3); }
    | EqualityExpressionNoIn "!==" RelationalExpressionNoIn { $$ = CYNew CYNotIdentical($1, $3); }
    ;

EqualityExpressionNoBF
    : RelationalExpressionNoBF { $$ = $1; }
    | EqualityExpressionNoBF "==" RelationalExpression { $$ = CYNew CYEqual($1, $3); }
    | EqualityExpressionNoBF "!=" RelationalExpression { $$ = CYNew CYNotEqual($1, $3); }
    | EqualityExpressionNoBF "===" RelationalExpression { $$ = CYNew CYIdentical($1, $3); }
    | EqualityExpressionNoBF "!==" RelationalExpression { $$ = CYNew CYNotIdentical($1, $3); }
    ;
/* }}} */
/* 11.10 Binary Bitwise Operators {{{ */
BitwiseANDExpression
    : EqualityExpression { $$ = $1; }
    | BitwiseANDExpression "&" EqualityExpression { $$ = CYNew CYBitwiseAnd($1, $3); }
    ;

BitwiseANDExpressionNoIn
    : EqualityExpressionNoIn { $$ = $1; }
    | BitwiseANDExpressionNoIn "&" EqualityExpressionNoIn { $$ = CYNew CYBitwiseAnd($1, $3); }
    ;

BitwiseANDExpressionNoBF
    : EqualityExpressionNoBF { $$ = $1; }
    | BitwiseANDExpressionNoBF "&" EqualityExpression { $$ = CYNew CYBitwiseAnd($1, $3); }
    ;

BitwiseXORExpression
    : BitwiseANDExpression { $$ = $1; }
    | BitwiseXORExpression "^" BitwiseANDExpression { $$ = CYNew CYBitwiseXOr($1, $3); }
    ;

BitwiseXORExpressionNoIn
    : BitwiseANDExpressionNoIn { $$ = $1; }
    | BitwiseXORExpressionNoIn "^" BitwiseANDExpressionNoIn { $$ = CYNew CYBitwiseXOr($1, $3); }
    ;

BitwiseXORExpressionNoBF
    : BitwiseANDExpressionNoBF { $$ = $1; }
    | BitwiseXORExpressionNoBF "^" BitwiseANDExpression { $$ = CYNew CYBitwiseXOr($1, $3); }
    ;

BitwiseORExpression
    : BitwiseXORExpression { $$ = $1; }
    | BitwiseORExpression "|" BitwiseXORExpression { $$ = CYNew CYBitwiseOr($1, $3); }
    ;

BitwiseORExpressionNoIn
    : BitwiseXORExpressionNoIn { $$ = $1; }
    | BitwiseORExpressionNoIn "|" BitwiseXORExpressionNoIn { $$ = CYNew CYBitwiseOr($1, $3); }
    ;

BitwiseORExpressionNoBF
    : BitwiseXORExpressionNoBF { $$ = $1; }
    | BitwiseORExpressionNoBF "|" BitwiseXORExpression { $$ = CYNew CYBitwiseOr($1, $3); }
    ;
/* }}} */
/* 11.11 Binary Logical Operators {{{ */
LogicalANDExpression
    : BitwiseORExpression { $$ = $1; }
    | LogicalANDExpression "&&" BitwiseORExpression { $$ = CYNew CYLogicalAnd($1, $3); }
    ;

LogicalANDExpressionNoIn
    : BitwiseORExpressionNoIn { $$ = $1; }
    | LogicalANDExpressionNoIn "&&" BitwiseORExpressionNoIn { $$ = CYNew CYLogicalAnd($1, $3); }
    ;

LogicalANDExpressionNoBF
    : BitwiseORExpressionNoBF { $$ = $1; }
    | LogicalANDExpressionNoBF "&&" BitwiseORExpression { $$ = CYNew CYLogicalAnd($1, $3); }
    ;

LogicalORExpression
    : LogicalANDExpression { $$ = $1; }
    | LogicalORExpression "||" LogicalANDExpression { $$ = CYNew CYLogicalOr($1, $3); }
    ;

LogicalORExpressionNoIn
    : LogicalANDExpressionNoIn { $$ = $1; }
    | LogicalORExpressionNoIn "||" LogicalANDExpressionNoIn { $$ = CYNew CYLogicalOr($1, $3); }
    ;

LogicalORExpressionNoBF
    : LogicalANDExpressionNoBF { $$ = $1; }
    | LogicalORExpressionNoBF "||" LogicalANDExpression { $$ = CYNew CYLogicalOr($1, $3); }
    ;
/* }}} */
/* 11.12 Conditional Operator ( ? : ) {{{ */
ConditionalExpression
    : LogicalORExpression { $$ = $1; }
    | LogicalORExpression "?" AssignmentExpression ":" AssignmentExpression { $$ = CYNew CYCondition($1, $3, $5); }
    ;

ConditionalExpressionNoIn
    : LogicalORExpressionNoIn { $$ = $1; }
    | LogicalORExpressionNoIn "?" AssignmentExpression ":" AssignmentExpressionNoIn { $$ = CYNew CYCondition($1, $3, $5); }
    ;

ConditionalExpressionNoBF
    : LogicalORExpressionNoBF { $$ = $1; }
    | LogicalORExpressionNoBF "?" AssignmentExpression ":" AssignmentExpression { $$ = CYNew CYCondition($1, $3, $5); }
    ;
/* }}} */
/* 11.13 Assignment Operators {{{ */
AssignmentExpression_
    : "=" AssignmentExpression { $$ = CYNew CYAssign(NULL, $2); }
    | "*=" AssignmentExpression { $$ = CYNew CYMultiplyAssign(NULL, $2); }
    | "/=" AssignmentExpression { $$ = CYNew CYDivideAssign(NULL, $2); }
    | "%=" AssignmentExpression { $$ = CYNew CYModulusAssign(NULL, $2); }
    | "+=" AssignmentExpression { $$ = CYNew CYAddAssign(NULL, $2); }
    | "-=" AssignmentExpression { $$ = CYNew CYSubtractAssign(NULL, $2); }
    | "<<=" AssignmentExpression { $$ = CYNew CYShiftLeftAssign(NULL, $2); }
    | ">>=" AssignmentExpression { $$ = CYNew CYShiftRightSignedAssign(NULL, $2); }
    | ">>>=" AssignmentExpression { $$ = CYNew CYShiftRightUnsignedAssign(NULL, $2); }
    | "&=" AssignmentExpression { $$ = CYNew CYBitwiseAndAssign(NULL, $2); }
    | "^=" AssignmentExpression { $$ = CYNew CYBitwiseXOrAssign(NULL, $2); }
    | "|=" AssignmentExpression { $$ = CYNew CYBitwiseOrAssign(NULL, $2); }
    ;

AssigneeExpression
    : LeftHandSideExpression { $$ = $1; }
@begin C
    | LexSetRegExp UnaryAssigneeExpression { $$ = $2; }
@end
    ;

AssigneeExpressionNoBF
    : LeftHandSideExpressionNoBF { $$ = $1; }
@begin C
    | UnaryAssigneeExpression { $$ = $1; }
@end
    ;

@begin C
AssigneeExpressionNoRE
    : LeftHandSideExpressionNoRE { $$ = $1; }
    | UnaryAssigneeExpression { $$ = $1; }
    ;
@end

AssignmentExpression
    : ConditionalExpression { $$ = $1; }
    | AssigneeExpression AssignmentExpression_ { $2->SetLeft($1); $$ = $2; }
    ;

AssignmentExpressionNoIn
    : ConditionalExpressionNoIn { $$ = $1; }
    | AssigneeExpression "=" AssignmentExpressionNoIn { $$ = CYNew CYAssign($1, $3); }
    | AssigneeExpression "*=" AssignmentExpressionNoIn { $$ = CYNew CYMultiplyAssign($1, $3); }
    | AssigneeExpression "/=" AssignmentExpressionNoIn { $$ = CYNew CYDivideAssign($1, $3); }
    | AssigneeExpression "%=" AssignmentExpressionNoIn { $$ = CYNew CYModulusAssign($1, $3); }
    | AssigneeExpression "+=" AssignmentExpressionNoIn { $$ = CYNew CYAddAssign($1, $3); }
    | AssigneeExpression "-=" AssignmentExpressionNoIn { $$ = CYNew CYSubtractAssign($1, $3); }
    | AssigneeExpression "<<=" AssignmentExpressionNoIn { $$ = CYNew CYShiftLeftAssign($1, $3); }
    | AssigneeExpression ">>=" AssignmentExpressionNoIn { $$ = CYNew CYShiftRightSignedAssign($1, $3); }
    | AssigneeExpression ">>>=" AssignmentExpressionNoIn { $$ = CYNew CYShiftRightUnsignedAssign($1, $3); }
    | AssigneeExpression "&=" AssignmentExpressionNoIn { $$ = CYNew CYBitwiseAndAssign($1, $3); }
    | AssigneeExpression "^=" AssignmentExpressionNoIn { $$ = CYNew CYBitwiseXOrAssign($1, $3); }
    | AssigneeExpression "|=" AssignmentExpressionNoIn { $$ = CYNew CYBitwiseOrAssign($1, $3); }
    ;

AssignmentExpressionNoBF
    : ConditionalExpressionNoBF { $$ = $1; }
    | AssigneeExpressionNoBF AssignmentExpression_ { $2->SetLeft($1); $$ = $2; }
    ;
/* }}} */
/* 11.14 Comma Operator {{{ */
Expression_
    : "," Expression { $$ = CYNew CYCompound($2); }
    | { $$ = NULL; }
    ;

ExpressionNoIn_
    : "," ExpressionNoIn { $$ = CYNew CYCompound($2); }
    | { $$ = NULL; }
    ;

ExpressionOpt
    : Expression { $$ = $1; }
    | LexSetRegExp { $$ = NULL; }
    ;

ExpressionNoInOpt
    : ExpressionNoIn { $$ = $1; }
    | LexSetRegExp { $$ = NULL; }
    ;

Expression
    : AssignmentExpression Expression_ { if ($2) { $2->AddPrev($1); $$ = $2; } else $$ = $1; }
    ;

ExpressionNoIn
    : AssignmentExpressionNoIn ExpressionNoIn_ { if ($2) { $2->AddPrev($1); $$ = $2; } else $$ = $1; }
    ;

ExpressionNoBF
    : AssignmentExpressionNoBF Expression_ { if ($2) { $2->AddPrev($1); $$ = $2; } else $$ = $1; }
    ;
/* }}} */

/* 12 Statements {{{ */
Statement_
    : Block { $$ = $1; }
    | VariableStatement { $$ = $1; }
    | EmptyStatement { $$ = $1; }
    | ExpressionStatement { $$ = $1; }
    | IfStatement { $$ = $1; }
    | IterationStatement { $$ = $1; }
    | ContinueStatement { $$ = $1; }
    | BreakStatement { $$ = $1; }
    | ReturnStatement { $$ = $1; }
    | WithStatement { $$ = $1; }
    | LabelledStatement { $$ = $1; }
    | SwitchStatement { $$ = $1; }
    | ThrowStatement { $$ = $1; }
    | TryStatement { $$ = $1; }
    ;

Statement
    : LexSetRegExp Statement_ { $$ = $2; }
    ;
/* }}} */
/* 12.1 Block {{{ */
Block_
    : Brace StatementListOpt "}" { $$ = $2; }
    ;

Block
    : Block_ { $$ = CYNew CYBlock($1); }
    ;

StatementList
    : Statement StatementListOpt { $1->SetNext($2); $$ = $1; }
    ;

StatementListOpt
    : StatementList { $$ = $1; }
    | LexSetRegExp { $$ = NULL; }
    ;
/* }}} */
/* 12.2 Variable Statement {{{ */
VariableStatement
    : "var" VariableDeclarationList Terminator { $$ = CYNew CYVar($2); }
    ;

VariableDeclarationList_
    : "," VariableDeclarationList { $$ = $2; }
    | { $$ = NULL; }
    ;

VariableDeclarationListNoIn_
    : "," VariableDeclarationListNoIn { $$ = $2; }
    | { $$ = NULL; }
    ;

VariableDeclarationList
    : VariableDeclaration VariableDeclarationList_ { $$ = CYNew CYDeclarations($1, $2); }
    ;

VariableDeclarationListNoIn
    : VariableDeclarationNoIn VariableDeclarationListNoIn_ { $$ = CYNew CYDeclarations($1, $2); }
    ;

VariableDeclaration
    : Identifier InitialiserOpt { $$ = CYNew CYDeclaration($1, $2); }
    ;

VariableDeclarationNoIn
    : Identifier InitialiserNoInOpt { $$ = CYNew CYDeclaration($1, $2); }
    ;

InitialiserOpt
    : Initialiser { $$ = $1; }
    | { $$ = NULL; }
    ;

InitialiserNoInOpt
    : InitialiserNoIn { $$ = $1; }
    | { $$ = NULL; }
    ;

Initialiser
    : "=" AssignmentExpression { $$ = $2; }
    ;

InitialiserNoIn
    : "=" AssignmentExpressionNoIn { $$ = $2; }
    ;
/* }}} */
/* 12.3 Empty Statement {{{ */
EmptyStatement
    : ";" { $$ = CYNew CYEmpty(); }
    ;
/* }}} */
/* 12.4 Expression Statement {{{ */
ExpressionStatement
    : ExpressionNoBF Terminator { $$ = CYNew CYExpress($1); }
    ;
/* }}} */
/* 12.5 The if Statement {{{ */
ElseStatementOpt
    : "else" Statement { $$ = $2; }
    | %prec "if" { $$ = NULL; }
    ;

IfStatement
    : "if" "(" Expression ")" Statement ElseStatementOpt { $$ = CYNew CYIf($3, $5, $6); }
    ;
/* }}} */

/* 12.6 Iteration Statements {{{ */
IterationStatement
    : DoWhileStatement { $$ = $1; }
    | WhileStatement { $$ = $1; }
    | ForStatement { $$ = $1; }
    | ForInStatement { $$ = $1; }
    ;
/* }}} */
/* 12.6.1 The do-while Statement {{{ */
DoWhileStatement
    : "do" Statement "while" "(" Expression ")" TerminatorOpt { $$ = CYNew CYDoWhile($5, $2); }
    ;
/* }}} */
/* 12.6.2 The while Statement {{{ */
WhileStatement
    : "while" "(" Expression ")" Statement { $$ = CYNew CYWhile($3, $5); }
    ;
/* }}} */
/* 12.6.3 The for Statement {{{ */
ForStatement
    : "for" "(" ForStatementInitialiser ";" ExpressionOpt ";" ExpressionOpt ")" Statement { $$ = CYNew CYFor($3, $5, $7, $9); }
    ;

ForStatementInitialiser
    : ExpressionNoInOpt { $$ = $1; }
    | LexSetRegExp "var" VariableDeclarationListNoIn { $$ = $3; }
    ;
/* }}} */
/* 12.6.4 The for-in Statement {{{ */
ForInStatement
    : "for" "(" ForInStatementInitialiser "in" Expression ")" Statement { $$ = CYNew CYForIn($3, $5, $7); }
    ;

ForInStatementInitialiser
    : LeftHandSideExpression { $$ = $1; }
    | LexSetRegExp "var" VariableDeclarationNoIn { $$ = $3; }
    ;
/* }}} */

/* 12.7 The continue Statement {{{ */
ContinueStatement
    : "continue" IdentifierOpt Terminator { $$ = CYNew CYContinue($2); }
    ;
/* }}} */
/* 12.8 The break Statement {{{ */
BreakStatement
    : "break" IdentifierOpt Terminator { $$ = CYNew CYBreak($2); }
    ;
/* }}} */
/* 12.9 The return Statement {{{ */
ReturnStatement
    : "return" ExpressionOpt Terminator { $$ = CYNew CYReturn($2); }
    ;
/* }}} */
/* 12.10 The with Statement {{{ */
WithStatement
    : "with" "(" Expression ")" Statement { $$ = CYNew CYWith($3, $5); }
    ;
/* }}} */

/* 12.11 The switch Statement {{{ */
SwitchStatement
    : "switch" "(" Expression ")" CaseBlock { $$ = CYNew CYSwitch($3, $5); }
    ;

CaseBlock
    : Brace CaseClausesOpt "}" { $$ = $2; }
    ;

CaseClausesOpt
    : CaseClause CaseClausesOpt { $1->SetNext($2); $$ = $1; }
    | DefaultClause CaseClausesOpt { $1->SetNext($2); $$ = $1; }
    | { $$ = NULL; }
    ;

CaseClause
    : "case" Expression ":" StatementListOpt { $$ = CYNew CYClause($2, $4); }
    ;

DefaultClause
    : "default" ":" StatementListOpt { $$ = CYNew CYClause(NULL, $3); }
    ;
/* }}} */
/* 12.12 Labelled Statements {{{ */
LabelledStatement
    : Identifier ":" Statement { $$ = CYNew CYLabel($1, $3); }
    ;
/* }}} */
/* 12.13 The throw Statement {{{ */
ThrowStatement
    : "throw" Expression Terminator { $$ = CYNew cy::Syntax::Throw($2); }
    ;
/* }}} */
/* 12.14 The try Statement {{{ */
TryStatement
    : "try" Block_ CatchOpt FinallyOpt { $$ = CYNew cy::Syntax::Try($2, $3, $4); }
    ;

CatchOpt
    : "catch" "(" Identifier ")" Block_ { $$ = CYNew cy::Syntax::Catch($3, $5); }
    | { $$ = NULL; }
    ;

FinallyOpt
    : "finally" Block_ { $$ = CYNew CYFinally($2); }
    | { $$ = NULL; }
    ;
/* }}} */

/* 13 Function Definition {{{ */
FunctionDeclaration
    : "function" Identifier "(" FormalParameterList ")" Brace FunctionBody "}" { $$ = CYNew CYFunctionStatement($2, $4, $7); }
    ;

FunctionExpression
    : "function" IdentifierOpt "(" FormalParameterList ")" Brace FunctionBody "}" { $$ = CYNew CYFunctionExpression($2, $4, $7); }
    ;

FormalParameterList_
    : "," FormalParameterList { $$ = $2; }
    | { $$ = NULL; }
    ;

FormalParameterList
    : Identifier FormalParameterList_ { $$ = CYNew CYFunctionParameter($1, $2); }
    | { $$ = NULL; }
    ;

FunctionBody
    : SourceElements { $$ = $1; }
    ;
/* }}} */
/* 14 Program {{{ */
Program
    : SourceElements { driver.program_ = CYNew CYProgram($1); }
    ;

SourceElements
    : SourceElement SourceElements { $1->SetNext($2); $$ = $1; }
    | LexSetRegExp { $$ = NULL; }
    ;

SourceElement_
    : Statement_ { $$ = $1; }
    | FunctionDeclaration { $$ = $1; }
    ;

SourceElement
    : LexSetRegExp SourceElement_ { $$ = $2; }
    ;
/* }}} */

@begin ObjectiveC
/* Cycript (Objective-C): @class Declaration {{{ */
ClassSuperOpt
    /* XXX: why the hell did I choose MemberExpressionNoBF? */
    : ":" LexSetRegExp MemberExpressionNoBF { $$ = $3; }
    | { $$ = NULL; }
    ;

ClassField
    : Expression Identifier ";"
    ;

ClassFieldListOpt
    : ClassFieldListOpt ClassField
    |
    ;

ClassFieldList
    : Brace ClassFieldListOpt "}" { $$ = NULL; }
    ;

MessageScope
    : "+" { $$ = false; }
    | "-" { $$ = true; }
    ;

TypeOpt
    : "(" Expression ")" { $$ = $2; }
    | "(" LexSetRegExp "void" ")" { $$ = NULL; }
    | { $$ = NULL; }
    ;

MessageParameter
    : Word ":" TypeOpt Identifier { $$ = CYNew CYMessageParameter($1, $3, $4); }
    ;

MessageParameterListOpt
    : MessageParameterList { $$ = $1; }
    | { $$ = NULL; }
    ;

MessageParameterList
    : MessageParameter MessageParameterListOpt { $1->SetNext($2); $$ = $1; }
    ;

MessageParameters
    : MessageParameterList { $$ = $1; }
    | Word { $$ = CYNew CYMessageParameter($1, NULL, NULL); }
    ;

ClassMessageDeclaration
    : MessageScope TypeOpt MessageParameters Brace FunctionBody "}" { $$ = CYNew CYMessage($1, $2, $3, $5); }
    ;

ClassMessageDeclarationListOpt
    : ClassMessageDeclarationListOpt ClassMessageDeclaration { $2->SetNext($1); $$ = $2; }
    | ClassMessageDeclarationListOpt Comment { $$ = $1; }
    | { $$ = NULL; }
    ;

ClassName
    : Identifier { $$ = $1; }
    | "(" AssignmentExpression ")" { $$ = $2; }
    ;

ClassNameOpt
    : ClassName { $$ = $1; }
    | { $$ = NULL; }
    ;

// XXX: this should be AssignmentExpressionNoRight
ClassProtocols
    : ShiftExpression ClassProtocolsOpt { $$ = CYNew CYProtocol($1, $2); }
    ;

ClassProtocolsOpt
    : "," ClassProtocols { $$ = $2; }
    | { $$ = NULL; }
    ;

ClassProtocolListOpt
    : "<" ClassProtocols ">" { $$ = $2; }
    | { $$ = NULL; }
    ;

ClassExpression
    : "@implementation" ClassNameOpt ClassSuperOpt ClassProtocolListOpt ClassFieldList ClassMessageDeclarationListOpt "@end" { $$ = CYNew CYClassExpression($2, $3, $4, $5, $6); }
    ;

ClassStatement
    : "@implementation" ClassName ClassSuperOpt ClassProtocolListOpt ClassFieldList ClassMessageDeclarationListOpt "@end" { $$ = CYNew CYClassStatement($2, $3, $4, $5, $6); }
    ;

CategoryName
    : "(" Word ")"
    ;

CategoryStatement
    : "@implementation" ClassName CategoryName ClassMessageDeclarationListOpt "@end" { $$ = CYNew CYCategory($2, $4); }
    ;

PrimaryExpressionBF
    : ClassExpression { $$ = $1; }
    ;

Statement_
    : ClassStatement { $$ = $1; }
    | CategoryStatement { $$ = $1; }
    ;
/* }}} */
/* Cycript (Objective-C): Send Message {{{ */
VariadicCall
    : "," AssignmentExpression VariadicCall { $$ = CYNew CYArgument(NULL, $2, $3); }
    | { $$ = NULL; }
    ;

SelectorCall_
    : SelectorCall { $$ = $1; }
    | VariadicCall { $$ = $1; }
    ;

SelectorWordOpt
    : WordOpt { driver.contexts_.back().words_.push_back($1); } { $$ = $1; }
    | AutoComplete { driver.mode_ = CYDriver::AutoMessage; YYACCEPT; }
    ;

SelectorCall
    : SelectorWordOpt ":" AssignmentExpression SelectorCall_ { $$ = CYNew CYArgument($1 ?: CYNew CYBlank(), $3, $4); }
    ;

SelectorList
    : SelectorCall { $$ = $1; }
    | Word { $$ = CYNew CYArgument($1, NULL); }
    ;

MessageExpression
    : "[" AssignmentExpression { driver.contexts_.push_back($2); } SelectorList "]" { driver.contexts_.pop_back(); } { $$ = CYNew CYSendDirect($2, $4); }
    | "[" LexSetRegExp "super" { driver.context_ = NULL; } SelectorList "]" { $$ = CYNew CYSendSuper($5); }
    ;

SelectorExpressionOpt
    : SelectorExpression_ { $$ = $1; }
    | { $$ = NULL; }
    ;

SelectorExpression_
    : WordOpt ":" SelectorExpressionOpt { $$ = CYNew CYSelectorPart($1, true, $3); }
    ;

SelectorExpression
    : SelectorExpression_ { $$ = $1; }
    | Word { $$ = CYNew CYSelectorPart($1, false, NULL); }
    ;

PrimaryExpressionNo
    : MessageExpression { $$ = $1; }
    | "@selector" "(" SelectorExpression ")" { $$ = CYNew CYSelector($3); }
    ;
/* }}} */
/* Cycript (Objective-C): @import Directive {{{ */
PathName
    : "/" PathName
    | "." PathName
    | Word PathName
    |
    ;

ImportPath
    : "<" PathName ">"
    | StringLiteral
    ;

SourceElement_
    : "@import" ImportPath { $$ = CYNew CYImport(); }
    ;
/* }}} */
@end

@begin C
/* Cycript (C): Pointer Indirection/Addressing {{{ */
UnaryAssigneeExpression
    : "*" UnaryExpressionNoRE { $$ = CYNew CYIndirect($2); }
    ;

UnaryExpression_
    : "&" UnaryExpression { $$ = CYNew CYAddressOf($2); }
    ;

MemberAccess
    : "->" "[" Expression "]" { $$ = CYNew CYIndirectMember(NULL, $3); }
    | "->" Identifier { $$ = CYNew CYIndirectMember(NULL, CYNew CYString($2)); }
    | "->" AutoComplete { driver.mode_ = CYDriver::AutoIndirect; YYACCEPT; }
    ;
/* }}} */
@end

/* YUI: Documentation Comments {{{ */
Statement_
    : Comment { $$ = $1; }
    ;
/* }}} */

@begin E4X
/* Lexer State {{{ */
LexPushRegExp
    : { driver.PushCondition(CYDriver::RegExpCondition); }
    ;

LexPushXMLContent
    : { driver.PushCondition(CYDriver::XMLContentCondition); }
    ;

LexPushXMLTag
    : { driver.PushCondition(CYDriver::XMLTagCondition); }
    ;

LexPop
    : { driver.PopCondition(); }
    ;

LexSetXMLContent
    : { driver.SetCondition(CYDriver::XMLContentCondition); }
    ;

LexSetXMLTag
    : { driver.SetCondition(CYDriver::XMLTagCondition); }
    ;
/* }}} */

XMLWhitespaceOpt
    : XMLWhitespace
    |
    ;

/* 8.1 Context Keywords {{{ */
Identifier
    : "namespace" { $$ = $1; }
    | "xml" { $$ = $1; }
    ;
/* }}} */
/* 8.3 XML Initialiser Input Elements {{{ */
XMLMarkup
    : XMLComment { $$ = $1; }
    | XMLCDATA { $$ = $1; }
    | XMLPI { $$ = $1; }
    ;
/* }}} */
/* 11.1 Primary Expressions {{{ */
PrimaryExpressionNo
    : PropertyIdentifier { $$ = CYNew CYPropertyVariable($1); }
    | XMLInitialiser { $$ = $1; }
    | XMLListInitialiser { $$ = $1; }
    ;

PropertyIdentifier
    : AttributeIdentifier { $$ = $1; }
    | QualifiedIdentifier { $$ = $1; }
    | WildcardIdentifier { $$ = $1; }
    ;
/* }}} */
/* 11.1.1 Attribute Identifiers {{{ */
AttributeIdentifier
    : "@" QualifiedIdentifier_ { $$ = CYNew CYAttribute($2); }
    ;

PropertySelector_
    : PropertySelector { $$ = $1; }
    | "[" Expression "]" { $$ = CYNew CYSelector($2); }
    ;

PropertySelector
    : Identifier { $$ = CYNew CYSelector($1); }
    | WildcardIdentifier { $$ = $1; }
    ;
/* }}} */
/* 11.1.2 Qualified Identifiers {{{ */
QualifiedIdentifier_
    : PropertySelector_ { $$ = CYNew CYQualified(NULL, $1); }
    | QualifiedIdentifier { $$ = $1; }
    ;

QualifiedIdentifier
    : PropertySelector "::" PropertySelector_ { $$ = CYNew CYQualified($1, $3); }
    ;
/* }}} */
/* 11.1.3 Wildcard Identifiers {{{ */
WildcardIdentifier
    : "*" { $$ = CYNew CYWildcard(); }
    ;
/* }}} */
/* 11.1.4 XML Initialiser {{{ */
XMLInitialiser
    : XMLMarkup { $$ = $1; }
    | XMLElement { $$ = $1; }
    ;

XMLElement
    : "<" XMLTagContent "/>" LexPop
    | "<" XMLTagContent ">" LexSetXMLContent XMLElementContentOpt "</" LexSetXMLTag XMLTagName XMLWhitespaceOpt ">" LexPop
    ;

XMLTagContent
    : LexPushXMLTag XMLTagName XMLAttributes
    ;

XMLExpression
    : Brace LexPushRegExp Expression "}" LexPop
    ;

XMLTagName
    : XMLExpression
    | XMLName
    ;

XMLAttributes_
    : XMLAttributes_ XMLAttribute
    |
    ;

XMLAttributes
    : XMLAttributes_ XMLWhitespace XMLExpression XMLWhitespaceOpt
    | XMLAttributes_ XMLWhitespaceOpt
    ;

XMLAttributeValue_
    : XMLExpression
    | XMLAttributeValue
    ;

XMLAttribute
    : XMLWhitespace XMLName XMLWhitespaceOpt "=" XMLWhitespaceOpt XMLAttributeValue_
    ;

XMLElementContent
    : XMLExpression XMLElementContentOpt
    | XMLMarkup XMLElementContentOpt
    | XMLText XMLElementContentOpt
    | XMLElement XMLElementContentOpt
    ;

XMLElementContentOpt
    : XMLElementContent
    |
    ;
/* }}} */
/* 11.1.5 XMLList Initialiser {{{ */
XMLListInitialiser
    : "<>" LexPushXMLContent XMLElementContent "</>" LexPop { $$ = CYNew CYXMLList($3); }
    ;
/* }}} */
/* 11.2 Left-Hand-Side Expressions {{{ */
PropertyIdentifier_
    : Identifier { $$ = $1; }
    | PropertyIdentifier { $$ = $1; }
    ;

MemberAccess
    : "." PropertyIdentifier { $$ = CYNew CYPropertyMember(NULL, $2); }
    | ".." PropertyIdentifier_ { $$ = CYNew CYDescendantMember(NULL, $2); }
    | "." "(" Expression ")" { $$ = CYNew CYFilteringPredicate(NULL, $3); }
    ;
/* }}} */
/* 12.1 The default xml namespace Statement {{{ */
/* XXX: DefaultXMLNamespaceStatement
    : "default" "xml" "namespace" "=" Expression Terminator { $$ = CYNew CYDefaultXMLNamespace($5); }
    ;

Statement_
    : DefaultXMLNamespaceStatement { $$ = $1; }
    ; */
/* }}} */
@end

/* ECMAScript5: Object Literal Trailing Comma {{{ */
PropertyNameAndValueList_
    : "," { $$ = NULL; }
    ;
/* }}} */

/* JavaScript 1.7: Array Comprehensions {{{ */
IfComprehension
    : "if" "(" Expression ")" { $$ = CYNew CYIfComprehension($3); }
    ;

ForComprehension
    : "for" "(" Identifier "in" Expression ")" { $$ = CYNew CYForInComprehension($3, $5); }
    | "for" "each" "(" Identifier "in" Expression ")" { $$ = CYNew CYForEachInComprehension($4, $6); }
    ;

ComprehensionListOpt
    : ComprehensionList { $$ = $1; }
    | IfComprehension { $$ = $1; }
    | { $$ = NULL; }
    ;

ComprehensionList
    : ForComprehension ComprehensionListOpt { $1->SetNext($2); $$ = $1; }
    ;

PrimaryExpressionNo
    : "[" AssignmentExpression ComprehensionList "]" { $$ = CYNew CYArrayComprehension($2, $3); }
    ;
/* }}} */
/* JavaScript 1.7: for each {{{ */
ForInStatement
    : "for" "each" "(" ForInStatementInitialiser "in" Expression ")" Statement { $$ = CYNew CYForEachIn($4, $6, $8); }
    ;
/* }}} */
/* JavaScript 1.7: let Statements {{{ *//*
LetStatement
    : "let" "(" VariableDeclarationList ")" Block_ { $$ = CYNew CYLet($3, $5); }
    ;

Statement_
    : LetStatement
    ;
*//* }}} */

/* JavaScript FTW: Function Statements {{{ */
Statement
    : LexSetRegExp FunctionDeclaration { driver.Warning(yylloc, "warning, FunctionDeclaration is a SourceElement, not a Statement"); } { $$ = $2; }
    ;
/* }}} */
/* JavaScript FTW: Optional Arguments {{{ */
FormalParameterList
    : Identifier "=" AssignmentExpression FormalParameterList_ { $$ = CYNew CYOptionalFunctionParameter($1, $3, $4); }
    ;
/* }}} */
/* JavaScript FTW: Ruby Blocks {{{ */
RubyProcParameterList_
    : "," RubyProcParameterList { $$ = $2; }
    | { $$ = NULL; }
    ;

RubyProcParameterList
    : Identifier RubyProcParameterList_ { $$ = CYNew CYFunctionParameter($1, $2); }
    | { $$ = NULL; }
    ;

RubyProcParametersOpt
    : "|" RubyProcParameterList "|" { $$ = $2; }
    | { $$ = NULL; }
    ;

RubyProcExpression
    : "{" RubyProcParametersOpt StatementListOpt "}" { $$ = CYNew CYRubyProc($2, $3); }
    ;

LeftHandSideExpression
    : LeftHandSideExpression RubyProcExpression { $$ = CYNew CYRubyBlock($1, $2); }
    ;

LeftHandSideExpressionNoBF
    : LeftHandSideExpressionNoBF RubyProcExpression { $$ = CYNew CYRubyBlock($1, $2); }
    ;

@begin C
LeftHandSideExpressionNoRE
    : LeftHandSideExpressionNoRE RubyProcExpression { $$ = CYNew CYRubyBlock($1, $2); }
    ;
@end
/* }}} */

%%
